/*
 * PHYNETOUCH. Electrophysiology Simulation Software.
 * Copyright (C) 2019  <Konstantinos A. Mountris> <konstantinos.mountris@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


#ifndef PHYNETOUCH_EXPORTERS_ENSIGHT_EXPORTER_TPP_
#define PHYNETOUCH_EXPORTERS_ENSIGHT_EXPORTER_TPP_


#include "PHYNETOUCH/engine/exporters/ensight_exporter.hpp"


namespace PNT {

template<short DIM, short CELL_NODES>
EnsightExporter<DIM, CELL_NODES>::EnsightExporter()
{}


template<short DIM, short CELL_NODES>
EnsightExporter<DIM, CELL_NODES>::~EnsightExporter()
{}


template<short DIM, short CELL_NODES>
void EnsightExporter<DIM, CELL_NODES>::SaveGeo(const std::vector<IMP::Vec<DIM, double>> &nodes, const std::vector<IMP::Cell<DIM, CELL_NODES>> &cells, const std::string &out_filename)
{
    namespace boost_fs = boost::filesystem;

    // Position of the last slash in the exporting file's name.
    std::size_t last_slash = out_filename.find_last_of("/\\");

    // Get the path directory of the exporting file name.
    std::string path = "";
    if (last_slash != std::string::npos) { path = out_filename.substr(0, last_slash); }

    // Create the path's directory if it doesn't exist.
    boost_fs::path dir(path);
    if (!path.empty() && !boost_fs::exists(dir)) { boost_fs::create_directories(dir); }

    // Search for the extension of the output geometry file.
    std::string ext = "";
    if (out_filename.find_last_of(".") != std::string::npos) {
        ext = out_filename.substr(out_filename.find_last_of("."));
    }

    // Open output geometry file.
    std::ofstream geo_out;
    if (ext == ".geo") {
        geo_out.open(out_filename, std::ofstream::out | std::ofstream::trunc);
    } else {
        geo_out.open(out_filename+".geo", std::ofstream::out | std::ofstream::trunc);
    }

    // Check if file was properly opened.
    if (!geo_out.is_open()) {
        throw std::invalid_argument(Logger::Error("Could not create Ensight geometry file. Check file path: "+out_filename));
    }

    // Write header.
    geo_out << "Ensight model geometry file generated by PHYNETOUCH-console v" << PHYNETOUCH_VERSION << "\n";
    geo_out << "For information about PHYNETOUCH-console, contact: konstantinos.mountris@gmail.com\n";
    geo_out << "node id off\nelement id off\n";
    geo_out << "part\n1\n";
    geo_out << "Model, Geometry 1\n";

    // Write nodes coordinates.
    geo_out << "coordinates\n" << nodes.size() << "\n";
    for (short d = 0; d != DIM; ++d) {
        for (std::size_t id = 0; id != nodes.size(); ++id)
            geo_out << nodes[id][d] << "\n";
    }
    // Fill missing coordinate dimensions wit zeros for problems with less than 3 dimensions.
    if (DIM < 3) {
        for (std::size_t id = 0; id != (3-DIM)*nodes.size(); ++id)
            geo_out << "0.0\n";
    }

    // Create a flag for each connected node of the grid.
    Eigen::SparseVector<int> conn_node_ids(nodes.size());

    // Write cells connectivity.
    if (DIM == 1 && CELL_NODES == 2) { geo_out << "bar2\n"; }
    else if (DIM == 2 && CELL_NODES == 2) { geo_out << "bar2\n"; }
    else if (DIM == 2 && CELL_NODES == 3) { geo_out << "tria3\n"; }
    else if (DIM == 2 && CELL_NODES == 4) { geo_out << "quad4\n"; }
    else if (DIM == 3 && CELL_NODES == 2) { geo_out << "bar2\n"; }
    else if (DIM == 3 && CELL_NODES == 3) { geo_out << "tria3\n"; }
    else if (DIM == 3 && CELL_NODES == 4) { geo_out << "tetra4\n"; }
    else if (DIM == 3 && CELL_NODES == 8) { geo_out << "hexa8\n"; }
    else {
        std::string error_msg = "Could not create Ensight geometry file due to not supported elements with Dimensions: " +
                                std::to_string(DIM) + " and Nodes: " + std::to_string(CELL_NODES);
        throw std::runtime_error(Logger::Error(error_msg));
    }

    // Output cells of connected nodes.
    geo_out << cells.size() << "\n";
    for (const auto &cell : cells) {
        for (short nid = 0; nid != CELL_NODES-1; ++nid) {
            geo_out << cell.N(nid)+1 << " ";
            conn_node_ids.coeffRef(cell.N(nid)) = 1;
        }
        geo_out << cell.N(CELL_NODES-1)+1 << "\n";
        conn_node_ids.coeffRef(cell.N(CELL_NODES-1)) = 1;
    }

    // Output 0D cells of not connected nodes.
    if (conn_node_ids.nonZeros() < static_cast<int>(nodes.size())) {
        geo_out << "point\n";
        geo_out << static_cast<int>(nodes.size()) - conn_node_ids.nonZeros() << "\n";
        for (int i = 0; i != conn_node_ids.rows(); ++i) {
            if (conn_node_ids.coeff(i) == 0)
                geo_out << i+1 << "\n";
        }
    }

    // Close the geometry output file.
    geo_out.close();

}


template<short DIM, short CELL_NODES>
void EnsightExporter<DIM, CELL_NODES>::SaveScalarField(const Eigen::VectorXd &scalar_field, const std::string &out_filename)
{
    // Create the path's directory if it doesn't exist.
    namespace fs = std::filesystem;
    fs::path filepath(out_filename);
    std::string parent_path_string{filepath.parent_path()};
    if (!fs::is_directory(parent_path_string) || !fs::exists(parent_path_string))
        fs::create_directory(parent_path_string);

    // Open output scalar field file.
    std::string ext = filepath.extension();
    std::ofstream output;
    if (ext == ".ens") {
        output.open(out_filename, std::ofstream::out | std::ofstream::trunc);
    } else {
        output.open(out_filename+".ens", std::ofstream::out | std::ofstream::trunc);
    }

    // Check if file was properly opened.
    if (!output.is_open()) {
        throw std::invalid_argument(Logger::Error("Could not create Ensight scalar field file. Check file path: "+out_filename));
    }

    // Write header file.
    output << "Ensight Model Post Process\npart\n  1\ncoordinates\n";

    // Write scalar field.
    output << scalar_field << "\n";

    // Close file.
    output.close();

}


template<short DIM, short CELL_NODES>
void EnsightExporter<DIM, CELL_NODES>::SaveVectorField(const Eigen::MatrixXd &vector_field, const std::string &out_filename)
{
    // Create the path's directory if it doesn't exist.
    namespace fs = std::filesystem;
    fs::path filepath(out_filename);
    std::string parent_path_string{filepath.parent_path()};
    if (!fs::is_directory(parent_path_string) || !fs::exists(parent_path_string))
        fs::create_directory(parent_path_string);

    // Open output vector field file.
    std::string ext = filepath.extension();
    std::ofstream output;
    if (ext == ".ens") {
        output.open(out_filename, std::ofstream::out | std::ofstream::trunc);
    } else {
        output.open(out_filename+".ens", std::ofstream::out | std::ofstream::trunc);
    }

    // Check if file was properly opened.
    if (!output.is_open()) {
        throw std::invalid_argument(Logger::Error("Could not create Ensight vector field file. Check file path: "+out_filename));
    }

    // Write header file.
    output << "Ensight Model Post Process\npart\n  1\ncoordinates\n";

    // Write vector field.
    for (int d = 0; d != vector_field.cols(); ++d) {
        output << vector_field.col(d) << "\n";
    }

    // Close file.
    output.close();

}


template<short DIM, short CELL_NODES>
void EnsightExporter<DIM, CELL_NODES>::SaveAnimation(const std::string &out_filename, const std::string &geo_filename,
        const std::vector<std::string> &state_files, const std::vector<std::string> &field_names,
        const std::vector<std::string> &field_types, const std::vector<std::size_t> &field_steps, double time_inc)
{
    namespace fs = std::filesystem;
    fs::path filepath(out_filename);
    std::string parent_path_string{filepath.parent_path()};
    if (!fs::is_directory(parent_path_string) || !fs::exists(parent_path_string))
        fs::create_directory(parent_path_string);

    // Open output animation file.
    std::string ext = filepath.extension();
    std::ofstream output;
    if (ext == ".case") {
        output.open(out_filename, std::ofstream::out | std::ofstream::trunc);
    } else {
        output.open(out_filename+".case", std::ofstream::out | std::ofstream::trunc);
    }

    // Get maximum steps number.
    int steps_num = *std::max_element(std::begin(field_steps), std::end(field_steps));

    // Write header.
    output << "# Ensight format output generated by: PhyNeTouchSim v." << PHYNETOUCH_VERSION << "\n";
    output << "# For information about PhyNeTouchSim, contact: konstantinos.mountris@gmail.com\n\n";
    output << "FORMAT\ntype: ensight gold\n\n";
    output << "GEOMETRY\n";
    output << "model: 1 " << geo_filename << "\n\n";

    output << "VARIABLE\n";
    int it = 0;
    for (const auto &states_file : state_files) {
        if (field_types[it] != "scalar" && field_types[it] != "vector") {
            std::string error_msg = "Could not save Ensight animation file. Supported field types: [scalar | vector].";
            throw std::invalid_argument(Logger::Error(error_msg));
        }
        output << field_types[it] << " per node: 1 " << field_names[it] << " " << states_file << "\n";
        it++;
    }
    output << "\n";

    output << "TIME\n";
    output << "time set: 1\n";
    output << "number of steps: " << steps_num << "\n";
    output << "filename start number: 0\n";
    output << "filename increment: 1\n";
    output << "time values: ";
    for (int i = 0; i != steps_num; ++i)
        output << i*time_inc << "\n";

    // Close file
    output.close();

}


} //end of namespace PNT


#endif // PHYNETOUCH_EXPORTERS_ENSIGHT_EXPORTER_TPP_